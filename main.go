package main

import (
	"fmt"
	"math"
)

func main() {
	p := basePerm(4)
	fmt.Println(nextPerm(*p))
	// fmt.Println(*p)
	// for i := 0; i < factorial(len(*p)); i++ {
	// 	*p = nextPerm(*p)
	// 	fmt.Println(*p)
	// }
}

func nextPerm2(p permutation) {
	facts := make([]int, len(p))
	for i := range facts {
		facts[i] = factorial(i)
	}
	p[len(p)-1] = 0
	for i := 0; i < len(p)-1; i++ {
		// d:=
	}
}

// factorial returns n!
func factorial(n int) (f int) {
	f = 1
	for i := 2; i <= n; i++ {
		f *= i
	}
	return f
}

func removeCrossPaths(ps pointSet, perm permutation) {

}

func naiveSoln(ps pointSet) (minDist float64, minPerm permutation) {
	// perm := basePerm(len(ps))
	// base := copyPerm(perm)
	// minPerm = copyPerm(perm)
	// dist := 0.0
	// minDist = math.MaxFloat64
	// notEqual := true
	// for notEqual {
	// 	dist = totalSqDist(ps, perm)
	// 	if dist < minDist {
	// 		minDist = dist
	// 		minPerm = copyPerm(perm)
	// 	}
	// 	perm = nextPerm(perm)
	// 	if comparePerms(perm, base) {
	// 		notEqual = false
	// 	}
	// }
	// minDist = totalDist(ps, minPerm)
	return minDist, minPerm
}

// copyPerm returns a new permution copy.
func copyPerm(x permutation) (y permutation) {
	y = make(permutation, len(x))
	for i := range x {
		y[i] = x[i]
	}
	return y
}

// compareIntSlices returns true if the two slices are nil
// or if they share the same length and values at each index.
func comparePerms(x, y permutation) (equal bool) {
	if x == nil && y == nil {
		equal = true
	} else if len(x) == len(y) {
		equal = true
		for i := 0; i < len(x); i++ {
			if x[i] != y[i] {
				equal = false
				break
			}
		}
	}
	return equal
}

// totalDist returns the total distance traversed across a
// path of points. A path is a permutation of points.
// Assumes the point set and the permutation are of equal
// dimension.
func totalDist(ps pointSet, perm permutation) (d float64) {
	n := len(ps)
	for i := 0; i+1 < n; i++ {
		d += math.Sqrt(sqDist(ps[perm[i]], ps[perm[i+1]]))
	}
	d += math.Sqrt(sqDist(ps[perm[0]], ps[perm[n-1]]))
	return d
}

// totalSqDist returns the total squared distance traversed
// across a path of points. A path is a permutation of
// points. Assumes teh point set and the permutation are of
// equal dimension.
func totalSqDist(ps pointSet, perm permutation) (d float64) {
	n := len(ps)
	for i := 0; i+1 < n; i++ {
		d += sqDist(ps[perm[i]], ps[perm[i+1]])
	}
	d += sqDist(ps[perm[0]], ps[perm[n-1]])
	return d
}

// sqDist returns the squared distance between two points.
// Assumes the points are equal in dimension.
func sqDist(x, y point) (d float64) {
	for i := range x {
		d += (x[i] - y[i]) * (x[i] - y[i])
	}
	return d
}

// lineThrough returns a function that is the line passing
// through two points. Assumes the points are two
// dimensional.
func lineThrough(x0, x1 point) func(x float64) float64 {
	return func(x float64) float64 { return (x1[1]-x0[1])/(x1[0]-x0[0])*(x-x0[0]) + x0[1] }
}

// crossAt returns the x value that is the crossing point
// for two lines generated by the given points x0, ..., x3.
// Line01 passes through Line23 only if they do not share
// the same slope and are in fact distinct lines.
func crossAt(x0, x1, x2, x3 point) (x float64) {
	d01 := diff(x0, x1)
	d02 := diff(x0, x2)
	d23 := diff(x2, x3)
	x = (d02[1] + x2[0]*(d23[1]/d23[0]) - x0[0]*(d01[1]/d01[0])) / (d23[1]/d23[0] - d01[1]/d01[0])
	return x
}

// diff returns a point where each value is the component-
// wise difference of the points x and y.
func diff(x, y point) (d point) {
	d = make(point, len(x))
	for i := range d {
		d[i] = y[i] - x[i]
	}
	return d
}

// pathsCross determines if the paths (x0,x1) and (x2,x3)
// cross and returns the cross point x if they do.
func pathsCross(x0, x1, x2, x3 point) (x float64, cross bool) {
	x = crossAt(x0, x1, x2, x3)
	if isOnRange(x, x0[0], x1[0]) && isOnRange(x, x2[0], x3[0]) {
		cross = true
	}
	return x, cross
}

// abs returns the absolute value of x.
func abs(x float64) (y float64) {
	if x < 0 {
		y = -x
	} else {
		y = x
	}
	return y
}

// isOnRange returns true if x is between a and b.
func isOnRange(x, a, b float64) (onRange bool) {
	if a <= b {
		if a <= x && x <= b {
			onRange = true
		}
	} else {
		if b <= x && x <= a {
			onRange = true
		}
	}
	return onRange
}
