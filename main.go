package main

import (
	"fmt"
	"math"
)

// point is a set of values.
type point []float64

// pointSet is a set of points.
type pointSet []point

// permutation is an ordering on Z(n).
type permutation []int

func main() {
	// ps := []point{
	// 	point{0, 0},
	// 	point{2, 2},
	// 	point{3, 1},
	// 	point{4, 2},
	// }
	perm := basePerm(4)
	for i := 0; i < factorial(len(perm)); i++ {
		fmt.Println(perm)
		perm = nextPerm(perm)
	}
	// fmt.Println(naiveSoln(ps))
}

// factorial returns n!
func factorial(n int) (f int) {
	f = 1
	for i := 2; i <= n; i++ {
		f *= i
	}
	return f
}

func removeCrossPaths(ps pointSet, perm permutation) {

}

func naiveSoln(ps pointSet) (minDist float64, minPerm permutation) {
	perm := basePerm(len(ps))
	base := copyPerm(perm)
	minPerm = copyPerm(perm)
	dist := 0.0
	minDist = math.MaxFloat64
	notEqual := true
	for notEqual {
		dist = totalSqDist(ps, perm)
		if dist < minDist {
			minDist = dist
			minPerm = copyPerm(perm)
		}
		perm = nextPerm(perm)
		if comparePerms(perm, base) {
			notEqual = false
		}
	}
	minDist = totalDist(ps, minPerm)
	return minDist, minPerm
}

// copyPerm returns a new permution copy.
func copyPerm(x permutation) (y permutation) {
	y = make(permutation, len(x))
	for i := range x {
		y[i] = x[i]
	}
	return y
}

// compareIntSlices returns true if the two slices are nil
// or if they share the same length and values at each index.
func comparePerms(x, y permutation) (equal bool) {
	if x == nil && y == nil {
		equal = true
	} else if len(x) == len(y) {
		equal = true
		for i := 0; i < len(x); i++ {
			if x[i] != y[i] {
				equal = false
				break
			}
		}
	}
	return equal
}

// nextPerm returns the next lexicographical permutation. If
// the current permutation is the last permutation, then the
// base permutation is returned.
func nextPerm(p permutation) (q permutation) {
	// Find largest index k such that p[k] < p[k+1]. If k
	// remains -1, p is the final lexicographical
	// permutation (ie n-1...210).
	n := len(p)
	q = make(permutation, n)
	k := -1
	for i := n - 2; 0 <= i; i-- {
		if p[i] < p[i+1] {
			k = i
			break
		}
	}

	if k == -1 {
		// Generate the first permuation.
		for i := 0; i < len(p); i++ {
			q[i] = i
		}
	} else {
		// Find largest index j > k such that p[k] < p[j].
		// If k = -1, return the base permutation
		// (0, 1, 2, ..., n-1).
		j := -1
		for i := n - 1; k < i; i-- {
			if p[k] < p[i] {
				j = i
				break
			}
		}

		// Copy p[0:k].
		for i := 0; i < k; i++ {
			q[i] = p[i]
		}

		// Swap p[k] and p[j].
		q[k] = p[j]
		q[j] = p[k]

		// 4. Reverse p[k+1:]
		for i := k + 1; i < n; i++ {
			q[i] = p[n-i-1]
		}
	}
	return q
}

// basePerm returns the base permutation (012...n-1).
func basePerm(n int) (p permutation) {
	p = make([]int, n)
	for i := 0; i < n; i++ {
		p[i] = i
	}
	return p
}

// totalDist returns the total distance traversed across a
// path of points. A path is a permutation of points.
// Assumes the point set and the permutation are of equal
// dimension.
func totalDist(ps pointSet, perm permutation) (d float64) {
	n := len(ps)
	for i := 0; i+1 < n; i++ {
		d += math.Sqrt(sqDist(ps[perm[i]], ps[perm[i+1]]))
	}
	d += math.Sqrt(sqDist(ps[perm[0]], ps[perm[n-1]]))
	return d
}

// totalSqDist returns the total squared distance traversed
// across a path of points. A path is a permutation of
// points. Assumes teh point set and the permutation are of
// equal dimension.
func totalSqDist(ps pointSet, perm permutation) (d float64) {
	n := len(ps)
	for i := 0; i+1 < n; i++ {
		d += sqDist(ps[perm[i]], ps[perm[i+1]])
	}
	d += sqDist(ps[perm[0]], ps[perm[n-1]])
	return d
}

// sqDist returns the squared distance between two points.
// Assumes the points are equal in dimension.
func sqDist(x, y point) (d float64) {
	for i := range x {
		d += (x[i] - y[i]) * (x[i] - y[i])
	}
	return d
}

// lineThrough returns a function that is the line passing
// through two points. Assumes the points are two
// dimensional.
func lineThrough(x0, x1 point) func(x float64) float64 {
	return func(x float64) float64 { return (x1[1]-x0[1])/(x1[0]-x0[0])*(x-x0[0]) + x0[1] }
}

// crossAt returns the x value that is the crossing point
// for two lines generated by the given points x0, ..., x3.
// Line01 passes through Line23 only if they do not share
// the same slope and are in fact distinct lines.
func crossAt(x0, x1, x2, x3 point) (x float64) {
	d01 := diff(x0, x1)
	d02 := diff(x0, x2)
	d23 := diff(x2, x3)
	x = (d02[1] + x2[0]*(d23[1]/d23[0]) - x0[0]*(d01[1]/d01[0])) / (d23[1]/d23[0] - d01[1]/d01[0])
	return x
}

// diff returns a point where each value is the component-
// wise difference of the points x and y.
func diff(x, y point) (d point) {
	d = make(point, len(x))
	for i := range d {
		d[i] = y[i] - x[i]
	}
	return d
}

// pathsCross determines if the paths (x0,x1) and (x2,x3)
// cross and returns the cross point x if they do.
func pathsCross(x0, x1, x2, x3 point) (x float64, cross bool) {
	x = crossAt(x0, x1, x2, x3)
	if isOnRange(x, x0[0], x1[0]) && isOnRange(x, x2[0], x3[0]) {
		cross = true
	}
	return x, cross
}

// abs returns the absolute value of x.
func abs(x float64) (y float64) {
	if x < 0 {
		y = -x
	} else {
		y = x
	}
	return y
}

// isOnRange returns true if x is between a and b.
func isOnRange(x, a, b float64) (onRange bool) {
	if a <= b {
		if a <= x && x <= b {
			onRange = true
		}
	} else {
		if b <= x && x <= a {
			onRange = true
		}
	}
	return onRange
}
