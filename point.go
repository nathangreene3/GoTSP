package main

import (
	"bufio"
	"encoding/csv"
	"io"
	"log"
	"math"
	"os"
	"strconv"
)

// point is an ordered tuple of values.
type point []float64 // x = (x0, x1, ...)

// pointSet is a set of points.
type pointSet []point

// getPoints returns a pointSet read from a CSV file.
func getPoints(filename string) pointSet {
	var pntSet pointSet
	var pnt point
	var line []string
	file, err := os.Open(filename)
	reader := csv.NewReader(bufio.NewReader(file))
	for {
		line, err = reader.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			log.Fatal(err)
		}
		pnt = make(point, len(line))
		for i := range line {
			pnt[i], err = strconv.ParseFloat(line[i], 64)
			if err != nil {
				log.Fatal(err)
			}
		}
		pntSet = append(pntSet, pnt)
	}
	return pntSet
}

func comparePoints(p, q point) bool {
	if len(p) != len(q) {
		return false
	}
	for i := range p {
		if p[i] != q[i] {
			return false
		}
	}
	return true
}

func comparePointSets(p, q pointSet) bool {
	if len(p) != len(q) {
		return false
	}
	for i := range p {
		if !comparePoints(p[i], q[i]) {
			return false
		}
	}
	return true
}

func copyPoint(p point) point {
	q := make(point, len(p))
	copy(q, p)
	return q
}

func (p point) copyPoint() point {
	return copyPoint(p)
}

func copyPointSet(ps pointSet) pointSet {
	newps := make(pointSet, len(ps))
	for i := range ps {
		newps[i] = copyPoint(ps[i])
	}
	return newps
}

func (ps pointSet) copyPointSet() pointSet {
	return copyPointSet(ps)
}

// sqDist returns the squared distance between two points.
// Assumes the points are equal in dimension.
func (p point) sqDist(q point) float64 {
	d := 0.0
	for i := range p {
		d += math.Pow(q[i]-p[i], 2)
	}
	return d
}

// sqDist returns the squared distance between two points.
// Assumes the points are equal in dimension.
func sqDist(p0, p1 point) float64 {
	d := 0.0
	for i := range p0 {
		d += (p1[i] - p0[i]) * (p1[i] - p0[i])
	}
	return d
}

// dist returns the distance between two points.
func (p point) dist(q point) float64 {
	return math.Sqrt(p.sqDist(q))
}

// dist returns the distance between two points.
func dist(p0, p1 point) float64 {
	return math.Sqrt(sqDist(p0, p1))
}

// totalDist returns the total distance traversed across a
// path of points. A path is a permutation of points.
// Assumes the point set and the permutation are of equal
// dimension.
func totalDist(ps pointSet, perm permutation) float64 {
	n := len(ps)
	d := dist(ps[perm[0]], ps[perm[n-1]])
	for i := 0; i+1 < n; i++ {
		d += dist(ps[perm[i]], ps[perm[i+1]])
	}
	return d
}

// totalSqDist returns the total squared distance traversed
// across a path of points. A path is a permutation of
// points. Assumes the point set and the permutation are of
// equal dimension.
func totalSqDist(ps pointSet, perm permutation) float64 {
	n := len(ps)
	d := sqDist(ps[perm[0]], ps[perm[n-1]])
	for i := 0; i+1 < n; i++ {
		d += sqDist(ps[perm[i]], ps[perm[i+1]])
	}
	return d
}

// lineThrough returns a function that is the line passing
// through two points. Assumes the points are two
// dimensional.
func lineThrough(x0, x1 point) func(x float64) float64 {
	return func(x float64) float64 { return (x1[1]-x0[1])*(x-x0[0])/(x1[0]-x0[0]) + x0[1] }
}

// crossAt returns the x value that is the crossing point
// for two lines generated by the given points x0, ..., x3.
// Line01 passes through Line23 only if they do not share
// the same slope and are in fact distinct lines.
func crossAt(x0, x1, x2, x3 point) float64 {
	d01 := diff(x0, x1)
	d02 := diff(x0, x2)
	d23 := diff(x2, x3)
	return (d02[1] + x2[0]*(d23[1]/d23[0]) - x0[0]*(d01[1]/d01[0])) / (d23[1]/d23[0] - d01[1]/d01[0])
}

// diff returns a point where each value is the component-
// wise difference of the points x and y.
func diff(x, y point) point {
	d := make(point, len(x))
	for i := range d {
		d[i] = y[i] - x[i]
	}
	return d
}

// pathsCross determines if the paths (x0,x1) and (x2,x3)
// cross and returns the cross point x if they do.
func pathsCross(x0, x1, x2, x3 point) (float64, bool) {
	x := crossAt(x0, x1, x2, x3)
	if isBetween(x, x0[0], x1[0]) && isBetween(x, x2[0], x3[0]) {
		return x, true
	}
	return x, false
}

// isBetween returns true if x is between a and b.
func isBetween(x, a, b float64) bool {
	if a < b {
		return a <= x && x <= b
	}
	return b <= x && x <= a // Potentially, a == b == x
}
